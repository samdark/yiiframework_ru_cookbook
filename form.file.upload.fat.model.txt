Как загрузить файл используя модель (вариант с тонким контроллером и толстой моделью)
=====================================================================================

Хорошей практикой считается создание тонких контроллеров и толстых моделей
всякий раз, когда это возможно. Это позволяет сделать код приложения более пригодным
для повторного использования.

Данный рецепт повторяет то, что уже было описано в рецепте
«[Как загрузить файл используя модель](form.file.upload)»
с той лишь разницей, что теперь мы не будем писать код, связанный с работой с файлами,
в контроллере, а вынесем его в модель.

Кроме того, в рецепте будут показаны модель и контроллер для того случая,
когда нам может пригодится функционал не только добавления объекта модели с файлом
(`C` в `CRUD`), но и обновления файла при редактировании уже существующего объекта модели
(`U` в `CRUD`), который был создан ранее и хранится в базе данных.

Контроллер
==========

Контроллер обыкновенный, почти такой же, какой генерируется при помощи
[Gii](http://yiiframework.ru/doc/guide/ru/topics.gii). В данном случае контроллер
не выполняет действий, связанных с загружаемыми файлами, напрямую. Всё, чем он
занимается — это обработка HTTP запросов, передача данных модели
и отображение представления.

~~~
[php]
class ItemController extends Controller{
    public function actionUpdate($id=null)
    {
        // в зависимости от аргумента создаем модель или ищем уже существующую
        if($id===null)
            $model=new Item;
        else if(!$model=Item::model()->findByPk($id))
            throw new CHttpException(404);

        if(isset($_POST['Item']))
        {
            $model->attributes=$_POST['Item'];
            if($model->save())
            {
                // отображаем успешное сообщение, обновляем страницу
                // или перенаправляем куда-либо ещё
                $this->refresh();
            }
        }

        $this->render('update',array('model'=>$model));
    }
}
~~~

Представление
=============

Форму в представлении можно создать при помощи класса [CHtml], но так как это уже было показано в рецепте
«[Как загрузить файл используя модель](http://yiiframework.ru/doc/cookbook/ru/form.file.upload)», то мы решили
сделать это через [CActiveForm].

~~~
[php]
<?php /* @var $this ItemController */ ?>
<?php /* @var $model Item */ ?>

<?php /* @var $form CActiveForm */ $form=$this->beginWidget('CActiveForm',array(
    'htmlOptions'=>array('enctype'=>'multipart/form-data'),
)); ?>
    <?php /* текстовое поле названия элемента */ ?>
    <div class="field">
        <?php echo $form->labelEx($model,'title'); ?>
        <?php echo $form->textField($model,'title'); ?>
        <?php echo $form->error($model,'title'); ?>
    </div>

    <?php /* поле для загрузки файла */ ?>
    <div class="field">
        <?php if($model->document): ?>
            <p><?php echo CHtml::encode($model->document); ?></p>
        <?php endif; ?>
        <?php echo $form->labelEx($model,'document'); ?>
        <?php echo $form->fileField($model,'document'); ?>
        <?php echo $form->error($model,'document'); ?>
    </div>

    <?php /* кнопка отправки */ ?>
    <div class="button">
        <?php echo CHtml::submitButton($model->isNewRecord ? 'Создать' : 'Сохранить'); ?>
    </div>
<?php $this->endWidget(); ?>
~~~

Структура формы стандартная. Отображаем две подписи (`<label />`), одно текстовое поле,
одно файловое поле, название файла (если он уже был загружен ранее) и кнопку отправки формы.
Не забываем указать в атрибуте `enctype` формы значение `multipart/form-data`.

Модель
======

Основная часть рецепта — это модель, в которой находится код, отвечающий за работу с файлом:
валидация, обработка файла и его сохранение происходит в ней.

Переопределяем метод [CActiveRecord::beforeSave], выполняемый перед сохранением AR-модели.
В нём получаем экземпляр класса загруженного файла и сохраняем его в нужное место на диске.

Следует обратить внимание на то, что в правилах валидации свойство `$document` помечено
как `unsafe`. Это необходимо для того, чтобы при обновлении модели, имя файла в таблице базы
данных сохранило своё старое значение если новый файл не был указан в файловом поле
(`<input type="file" />`).

Под обновлением понимается редактирование модели, то есть тогда, когда
`CActiveRecord::getIsNewRecord()` возвращает `false` и активным сценарием валидации
является `update`.

~~~
[php]
/**
 * @property integer $id
 * @property string $title
 * @property string $document
 */
class Item extends CActiveRecord{
    public $document;

    public static function model($className=__CLASS__)
    {
        return parent::model($className);
    }

    public function tableName()
    {
        return '{{item}}';
    }

    public function rules()
    {
        return array(
            array('title','required'),
            array('document','file','types'=>'doc,docx,xls,xlsx,odt,pdf','allowEmpty'=>true),
            array('document','unsafe'),
        );
    }

    public function beforeSave()
    {
        if(parent::beforeSave())
        {
            if($document=CUploadedFile::getInstance($this,'document'))
            {
                $this->deleteDocument(); // старый документ удалим, потому что загружаем новый

                $this->document=$document;
                $this->document->saveAs(Yii::getPathOfAlias('webroot.media').DIRECTORY_SEPARATOR.$this->document);
            }
            return true;
        }
        return false;
    }

    public function beforeDelete()
    {
        if(parent::beforeDelete())
        {
            $this->deleteDocument(); // удалили модель? удаляем и файл
            return true;
        }
        return false;
    }

    public function deleteDocument()
    {
        $documentPath=Yii::getPathOfAlias('webroot.media').DIRECTORY_SEPARATOR.$this->document;
        if(is_file($documentPath))
            unlink($documentPath);
    }
}
~~~

`DDL` таблицы для приведённой выше AR-модели:

~~~
[sql]
DROP TABLE IF EXISTS `tbl_item`;
CREATE TABLE `tbl_item` (
    `id` int(11) NOT NULL AUTO_INCREMENT,
    `title` varchar(250) NOT NULL DEFAULT '',
    `document` varchar(250) NOT NULL DEFAULT '',
    PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
~~~

Поведение
=========

Код для работы с файлом при необходимости можно вынести в поведение ([CActiveRecordBehavior]).
Ниже представлен рабочий пример такого поведения:

~~~
[php]
/**
 * @property string $savePath путь к директории, в которой сохраняем файлы
 */
class UploadableFileBehavior extends CActiveRecordBehavior{
	/**
	 * @var string название атрибута, хранящего в себе имя файла и файл
	 */
	public $attributeName='document';
	/**
	 * @var string алиас директории, куда будем сохранять файлы
	 */
	public $savePathAlias='webroot.media';
	/**
	 * @var array сценарии валидации к которым будут добавлены правила валидации загрузки файлов
	 */
	public $scenarios=array('insert','update');
	/**
	 * @var string типы файлов, которые можно загружать (нужно для валидации)
	 */
	public $fileTypes='doc,docx,xls,xlsx,odt,pdf';

	/**
	 * Шорткат для Yii::getPathOfAlias($this->savePathAlias).DIRECTORY_SEPARATOR. Возвращает путь к директории,
	 * в которой будут сохраняться файлы.
	 * @return string путь к директории, в которой сохраняем файлы
	 */
	public function getSavePath()
	{
		return Yii::getPathOfAlias($this->savePathAlias).DIRECTORY_SEPARATOR;
	}

	public function beforeValidate($event)
	{
		// валидируем вручную, потому как изменить метод rules() у $owner мы не можем и правил всего два
		if(in_array($this->getOwner()->getScenario(),$this->scenarios))
		{
			// альтерантива правилу array('document','file','types'=>'...','allowEmpty'=>true)
			$fileValidator=new CFileValidator();
			$fileValidator->attributes=array($this->attributeName);
			$fileValidator->types=$this->fileTypes;
			$fileValidator->allowEmpty=true;
			$fileValidator->validate($this->getOwner(),array($this->attributeName));

			// альтерантива правилу array('document','unsafe')
			$unsafeValidator=new CUnsafeValidator();
			$unsafeValidator->attributes=array($this->attributeName);
			$unsafeValidator->validate($this->getOwner(),array($this->attributeName));
		}
		return true;
	}

	public function beforeSave($event)
	{
		if($file=CUploadedFile::getInstance($this->getOwner(),$this->attributeName))
		{
			$this->deleteFile(); // старый файл удалим, потому что загружаем новый

			$this->getOwner()->setAttribute($this->attributeName,$file->getName());
			$file->saveAs($this->getSavePath().$file->getName());
		}
		return true;
	}

	public function beforeDelete($event)
	{
		$this->deleteFile(); // удалили модель? удаляем и файл от неё
	}

	public function deleteFile()
	{
		$filePath=$this->getSavePath().$this->getOwner()->getAttribute($this->attributeName);
		if(is_file($filePath))
			unlink($filePath);
	}
}
~~~

В поведении мы делаем тоже самое, что и в модели ранее. Код для работы с файлом мы просто вынесли
из модели в поведение, тем самым увеличив возможность повторного использования кода.

Модель теперь простая и понятная:

~~~
[php]
/**
 * @property integer $id
 * @property string $title
 * @property string $document
 */
class Item extends CActiveRecord{
    public static function model($className=__CLASS__)
    {
        return parent::model($className);
    }

    public function tableName()
    {
        return '{{item}}';
    }

    public function rules()
    {
        return array(
            array('title','required'),
            // после генерации модели при помощи Gii нужно убрать валидацию у атрибута $document
            // это будет мешать правильно работать валидации загружаемого файла и поведению UploadableFileBehavior
        );
    }

    public function behaviors()
    {
        return array(
            // наше поведение для работы с файлом
            'uploadableFile'=>array(
                'class'=>'application.components.UploadableFileBehavior',
                // конфигурируем нужные свойства класса UploadableFileBehavior
                // ...
            ),
        );
    }
}
~~~

Заключение
==========

Стоит иметь ввиду, что данный рецепт является всего лишь примером. Так, например, мы не учли
ситуацию, когда две разные модели могут иметь два файла с одним и тем-же файлом.

---
  - `Оригинальный рецепт`: [как загрузить файл используя модель](form.file.upload)
  - `Английский рецепт`: [how to upload a file using a model](http://www.yiiframework.com/wiki/2/)
  - [File upload and update / error actions](http://www.yiiframework.com/wiki/2/#c3137)
  - `Автор`: [resurtm](http://resurtm.kz/)
  - `Обсуждение и комментарии`: [тема на форуме](http://yiiframework.ru/forum/)
